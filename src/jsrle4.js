/* jsrle4 - simple Run Length Encoding for 4bytes words data
 * Copyright (C) 2013 - michal@post.pl
 * https://github.com/michals/jsrle4/
 * lincese: Apache 2.0
 */

/*jslint bitwise: true, plusplus: true*/
/*global Uint8ClampedArray, ArrayBuffer, Uint8Array, Uint32Array*/
var RLE4 = {
    // data must be Uint8ClampedArray with length == n*4, where n is an integer
    // returns (hopefully) smaller Uint8ClampedArray that can be reconstructed via decompress
    compress: function (data) {
        "use strict";
        var pos = 0, // position in data[]
            curr = new ArrayBuffer(4), // current 4 bytes
            curr32 = new Uint32Array(curr), // uint32[] view of curr 
            curr8 = new Uint8Array(curr), // uint8[] view of curr
            next = new ArrayBuffer(4), // next 4 bytes
            next32 = new Uint32Array(next), // uint32[] view of next
            next8 = new Uint8Array(next), // uint8[] view of next
            count = 1, // counter for repeated words
            ret = []; // return array (to be casted later)
        // load next 4 bytes from data into dst array and update pos
        function next4(dst) {
            var i;
            for (i = 0; i < 4; i++) {
                dst[i] = data[pos++];
            }
        }
        next4(curr8); // load next 4 bytes and store it in curr
        while (true) {
            if (pos + 3 < data.length) { // if we can read at least 4 bytes
                next4(next8); // load next 4 bytes
                if (curr32[0] === next32[0] && count < 255) { // count must fit into uint8
                    count++; // we next 4 bytes same as current
                } else { // need to reset counter and start new sequence
                    ret.push(count, curr8[0], curr8[1], curr8[2], curr8[3]);
                    curr32[0] = next32[0];
                    count = 1;
                }
            } else { // no more data, push last sequence and finish
                ret.push(count, curr8[0], curr8[1], curr8[2], curr8[3]);
                break;
            }
        }
        // return array of bytes as Uint8ClampedArray 
        return new Uint8ClampedArray(ret);
    },
    // reverse of compress. data should be generated by RLE4.compress.
    // data should be Uint8ClampedArray with length = n*5, where n is an integer
    decompress: function (data) {
        "use strict";
        var ret = [], pos, i, count;
        // each block is 5 bytes: [count, b0, b1, b2, b3]
        for (pos = 0; pos < data.length; pos += 5) {
            count = data[pos];
            for (i = 0; i < count; i++) {
                ret.push(data[pos + 1], data[pos + 2], data[pos + 3], data[pos + 4]);
            }
        }
        // return array of bytes as Uint8ClampedArray
        return new Uint8ClampedArray(ret);
    }
};
