/* jsrle4 - simple Run Length Encoding for 4bytes words data
 * Copyright (C) 2013 - michal@post.pl
 * https://github.com/michals/jsrle4/
 * lincese: Apache 2.0
 */

/*jslint bitwise: true, plusplus: true*/
/*global Uint8ClampedArray, ArrayBuffer, Uint8Array, Uint32Array*/
var RLE4 = {
    // data must be Uint8ClampedArray with length == n*4, where n is an integer
    // returns (hopefully) smaller string that can be used to reconstruct data via decompress
    compress: function (data) {
        "use strict";
        var pos = 0, // position in data[]
            curr = new ArrayBuffer(4), // current 4 bytes
            curr32 = new Uint32Array(curr), // uint32[] view of curr 
            curr8 = new Uint8Array(curr), // uint8[] view of curr
            next = new ArrayBuffer(4), // next 4 bytes
            next32 = new Uint32Array(next), // uint32[] view of next
            next8 = new Uint8Array(next), // uint8[] view of next
            count = 1, // counter for repeated words
            ret = []; // return array (to be casted later)
        // load next 4 bytes from data into dst array and update pos
        function next4(dst) {
            var i;
            for (i = 0; i < 4; i++) {
                dst[i] = data[pos++];
            }
        }
        next4(curr8); // load next 4 bytes and store it in curr
        while (true) {
            if (pos + 3 < data.length) { // if we can read at least 4 bytes
                next4(next8); // load next 4 bytes
                if (curr32[0] === next32[0] && count < 255) { // count must fit into uint8
                    count++; // we next 4 bytes same as current
                } else { // need to reset counter and start new sequence
                    ret.push(count, curr8[0], curr8[1], curr8[2], curr8[3]);
                    curr32[0] = next32[0];
                    count = 1;
                }
            } else { // no more data, push last sequence and finish
                ret.push(count, curr8[0], curr8[1], curr8[2], curr8[3]);
                break;
            }
        }
        for(pos = 0; pos<ret.length; pos++) {
            ret[pos] = String.fromCharCode(ret[pos]);
        }
        return ret.join('');
    },
    // reverse of compress. data should be generated by RLE4.compress.
    // if dest is given, then data is decompressed to dest array
    decompress: function (str, dest) {
        "use strict";
        var pos, i, count, n=0;
        if (dest === undefined) {
            dest = [];
        }
        // each block is 5 bytes: [count, b0, b1, b2, b3]
        for (pos = 0; pos < str.length; pos += 5) {
            count = str.charCodeAt(pos);
            for (i = 0; i < count; i++) {
                dest[n++] = str.charCodeAt(pos + 1);
                dest[n++] = str.charCodeAt(pos + 2);
                dest[n++] = str.charCodeAt(pos + 3);
                dest[n++] = str.charCodeAt(pos + 4);
            }
        }
        return dest;
    }
};

